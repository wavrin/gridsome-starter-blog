{"hash":"2eb9ce04084dc7c2ecc4d5274feb7a5546b4e884","data":{"post":{"title":"Ruby on Rails development with Docker","path":"/ruby-on-rails-development-with-docker/","date":"4. March 2019","timeToRead":5,"tags":[{"id":"Docker","title":"Docker","path":"/tag/Docker/"},{"id":"Rails","title":"Rails","path":"/tag/Rails/"}],"description":"You may see an app you worked on months ago, but you don’t remember what it was about. Then you run into trouble trying to start it again because you have moved on to a new version of Rails. And probably a new version of Ruby too. One way to get around this version issue and save your sanity down the road: Use Docker.","content":"<p>There’s a terrific book called <a href=\"https://www.justinweiss.com/practicing-rails/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Practicing Rails</a>, by Justin Weiss. One of the key concepts that really stuck with me is creating many small apps to test and experiment with new features and ideas. There’s just one potential headache that you may encounter: you end up with, over time, a whole bunch of apps using different versions of <a href=\"https://rubyonrails.org/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Ruby on Rails</a> and/or <a href=\"https://www.ruby-lang.org/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Ruby</a>.</p>\n<p>You may see an app you worked on months ago, but you don’t remember what it was about. Then you run into trouble trying to start it again because you have moved on to a new version of Rails. And probably a new version of Ruby too. One way to get around this version issue and save your sanity down the road: Use <a href=\"https://www.docker.com/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Docker</a>.</p>\n<p>By using Docker you can lock-in the versions and in the future more easily start your app up again.</p>\n<p>In this short guide we’ll start a Rails app using containers.</p>\n<p>We’ll need to install <a href=\"https://www.docker.com/products/docker-desktop\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Docker Desktop</a>. Once we have Docker running locally, we can begin:</p>\n<p><strong>Start bash in a new container:</strong></p>\n<p><code class=\"language-text\">docker run -it --rm -v ${PWD}:/usr/src/app ruby:2.4 bash</code></p>\n<p>This command starts up a container running Ruby and puts us right into it at a bash prompt. In this example, our container will be running Ruby 2.4, as the container was created using the official Ruby 2.4 image from <a href=\"https://hub.docker.com/_/ruby/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Docker Hub</a>. But we can specify whatever version you want.</p>\n<p>If we don’t already have the Ruby 2.4 image locally, the first time you run this it takes some time. But it will then be cached locally, so next time it will go quite quickly.</p>\n<p>Now, while we are in the container, we can install rails.</p>\n<p><strong>Install Rails:</strong></p>\n<p><code class=\"language-text\">gem install rails</code></p>\n<p>And with that, we can create a rails app.</p>\n<p><strong>Create rails app:</strong></p>\n<pre class=\"language-text\"><code class=\"language-text\">cd /usr/src/app\nrails new myapp --skip-test --skip-bundle --database=postgresql</code></pre>\n<p>As you may have noticed, we are using <a href=\"https://www.postgresql.org/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">PostgreSQL</a>. In the past, if we were just creating one-off Rails projects to try out a new feature or experiment, we would probably just use the default <a href=\"https://www.sqlite.org/index.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">SQLite</a>; it can be a bit time-consuming to run postgres locally. But with Docker, it’s super easy. And if we ever further develop the application and want to push it to production we will be glad we did this.</p>\n<p>So far we’ve been working <em>inside</em> the container. Let’s get out of there.</p>\n<p><strong>Exit the container:</strong></p>\n<p><code class=\"language-text\">exit</code></p>\n<p>Even though we created the Rails project while we were inside the container, you will notice that we can see the code after we exited. Our code stays locally and when we start a container it’s mounted inside.</p>\n<p><strong>Change directory into your app:</strong></p>\n<p><code class=\"language-text\">cd myapp</code></p>\n<p>The Ruby image we used got us started. But we need to actually build the image - based on that same Ruby image - with everything we need to run our application. The nuts and bolts of this isn’t so important right now. But what we need is a Dockerfile.</p>\n<p><strong>Create a Dockerfile</strong>. Here is a good starter one:</p>\n<pre class=\"language-text\"><code class=\"language-text\">FROM ruby:2.4\nLABEL maintainer=&quot;your-email-goes-here&quot;\n\n# Ensure we install an up-to-date version of Node\n# See https://github.com/yarnpkg/yarn/issues/2888\nRUN curl -sL https://deb.nodesource.com/setup_6.x | bash -\n\n# Ensure latest packages for Yarn\nRUN curl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | apt-key add -\nRUN echo &quot;deb https://dl.yarnpkg.com/debian/ stable main&quot; | \\\n  tee /etc/apt/sources.list.d/yarn.list\n\n# Install packages\nRUN apt-get update -yqq &amp;&amp; apt-get install -yqq --no-install-recommends \\\n  nodejs \\\n  yarn\n\nCOPY Gemfile* /usr/src/app/\nWORKDIR /usr/src/app\nRUN bundle install\n\nCOPY . /usr/src/app/\n\nCMD [&quot;bin/rails&quot;, &quot;s&quot;, &quot;-b&quot;, &quot;0.0.0.0&quot;]</code></pre>\n<p>And we’ll need to update our database configuration.</p>\n<p><strong>Update database.yml</strong></p>\n<pre class=\"language-text\"><code class=\"language-text\">default: &amp;default\n  adapter: postgresql\n  encoding: unicode\n  host: database\n  username: postgres\n  password: some-long-password\n  database: myapp_development\n  pool: 5\n  variables:\n    statement_timeout: 5000\n\ndevelopment:\n  &lt;&lt;: *default\n\ntest:\n  &lt;&lt;: *default\n  database: myapp_test\n\nproduction:\n  &lt;&lt;: *default</code></pre>\n<p>Now we can build our docker image.</p>\n<p><strong>Build a docker image:</strong></p>\n<p><code class=\"language-text\">docker build .</code></p>\n<p>Our application is actually made up of different services, so we need to describe them. We have our “web” service that consists of our running Rails application. And we’ll need a separate “database” service for the postgres database (as it’ll be running in its own container). This is where the docker-compose.yml file comes in.</p>\n<p><strong>Create a docker-compose.yml file:</strong></p>\n<pre class=\"language-text\"><code class=\"language-text\">version: &quot;3&quot;\n\nservices:\n  web:\n    build: .\n    ports:\n      - &quot;3000:3000&quot;\n    volumes:\n      - .:/usr/src/app\n\n  database:\n    image: postgres</code></pre>\n<p>If you are curious why the database service is so simply stated, it’s because we don’t need to build anything. It is grabbing the official postgres image from Docker Hub. The image has everything it needs for us to launch a database container. Rails already knows the port.</p>\n<p>To create our development database, we need to launch the database container first:</p>\n<p><code class=\"language-text\">docker-compose up -d database</code></p>\n<p>The -d flag allows the container to run in the background - “detached” mode, to be specific - so we don’t see any output.</p>\n<p>Now, with postgres running, we can use Rails create the database:</p>\n<p><code class=\"language-text\">docker-compose run --rm web bin/rails db:create</code></p>\n<p>There are two parts to this command: a Docker part and a Rails part. The Docker part - <code class=\"language-text\">docker-compose run --rm web</code> - is launching our “web” container but will delete the container (the \"--rm\" part) as soon as the command runs. The rest of the command — <code class=\"language-text\">bin/rails db:create</code> - is the Rails command to create the database.</p>\n<p>With the database created, we can now start up the web container.</p>\n<p><strong>Start it up:</strong></p>\n<p><code class=\"language-text\">docker-compose up</code></p>\n<p>This command starts up all the services listed in your docker-compose.yml file.</p>\n<p>That’s pretty much it. Our Rails app should be running locally at <a href=\"http://localhost:3000/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">http://localhost:3000/</a></p>\n<p><strong>Starting, Stopping, and other important commands</strong></p>\n<p>When you want to get your services running:</p>\n<p><code class=\"language-text\">docker-compose up</code></p>\n<p>When you want to get your services running, but OK to run in the background:</p>\n<p><code class=\"language-text\">docker-compose up -d</code></p>\n<p>Check to see if you have any containers running:</p>\n<p><code class=\"language-text\">docker-compose ps</code></p>\n<p>When you want to stop your services:</p>\n<p><code class=\"language-text\">docker-compose stop</code></p>\n<p>Run a one-off rails command and delete the container after completion:</p>\n<p><code class=\"language-text\">docker-compose run --rm web bin/rails db:migrate</code></p>\n<p><strong>Epilogue</strong></p>\n<p>We can now easily create lots of Rails apps. And in a year from now, when we ask ourselves, “What’s this app all about?” we won’t have to jump through any hoops to get it running again; our Ruby and Rails versions will all be nicely tucked away and we can easily launch a new container to run the app.</p>\n<p>If we decide that one of our apps will go to production eventually, there are some advanced topics to consider:</p>\n<ul>\n<li>We’ll want to move your database information into environment variables.</li>\n<li>In Development, Rails compiles our assets on each request. But in Production, we’ll need to pre-compile the assets.</li>\n<li>We’d likely add more services, like Redis.</li>\n<li>If we are developing a lot on this application, we may grow tired of it running <code class=\"language-text\">bundle install</code> all the time. Gem caching is a great strategy to add.</li>\n</ul>\n<p>If you are interested in these more advanced topics, I highly recommend Rob Isenberg’s <a href=\"https://pragprog.com/book/ridocker/docker-for-rails-developers\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Docker for Rails Developers</a>.</p>\n"}},"context":{}}